6.4.2 事件模拟
3.7.3节描述了一个重要的排队问题。设有一个系统，比如银行，顾客们到达并排队等候，直到在总计k个出纳员中有一个出纳员有空。
顾客的到达情况由概率分布函数控制，服务时间(当出纳员有空时，用于服务的时间量)也是如此。
我们关心的是平均一位顾客要等多久或所排的队伍可能有多长这类统计问题。
对于某些概率分布以及k的一些值，答案可以精确地计算出来。
然而随着k的变大，显然分析变得越来越困难，因此使用计算机模拟银行的运作就很必要。
用这种方法，银行官员可以确定为保证合理顺畅的服务需要多少出纳员。
模拟由处理中的事件组成。这里的两个事件是：
(a)一位顾客的到达；
(b)一位顾客的离去，从而腾出一名出纳员。
我们可以使用概率函数来生成一个输入流，它由每位顾客的到达时间和服务时间的序偶组成，并以到达时间排序。
我们不必使用一天中的准确时间，而是使用一份单位时间量，称之为一个滴答(tick)。
进行这种模拟的一个方法是在0滴答处启动一台模拟钟表。让钟表一次走一个滴答，同时查看是否有事件发生。如果有，那么处理这个(或这些)事件，搜集统计资料。
当没有顾客留在输入流中且所有的出纳员都闲着的时候，模拟结束。
这种模拟策略的问题是，其运行时间不依赖于顾客数或事件数(每位顾客有两个事件)，却依赖于滴答数，而后者实际并不是输入的一部分。
下面来看为什么这很重要：假设将钟表的单位改成毫滴答(millitick)并将输入中的所有时间乘以1000，则结果将是：模拟用时长1000倍！
避免这种问题的关键是在每一个阶段让钟表直接走到下一个事件时间。从概念上看这是容易做到的
。在任一时刻，可能出现的下一事件是：
(a)输入文件中的下一位顾客到达；
(b)在一名出纳员处一位顾客离开。
由于可以得知事件发生的所有时间，因此只需找出最近要发生的事件并
处理这个事件即可。
如果事件是离开，那么处理过程包括搜集离开的顾客的统计资料以及检验队伍(队列)，看是否还有其他顾客在等待。
如果有，那么加上这位顾客，处理所需要的统计资料，计算顾客将要离开的时间，并将离开事件加到等待发生的事件集中去。
如果事件是到达，那么检查是否有空闲的出纳员。
若没有，就把这一到达事件放到队伍(队列)中去；
否则，分配给顾客一个出纳员，计算顾客的离开时间，并将离开事件加到等待发生的事件集中去。
在等待的顾客队伍可以实现为一个队列。
由于需要找到最近将要发生的事件，因此合适的办法是将等待发生的离开事件的集合编入一个优先队列中。
下一事件是下一个到达或下一个离开(哪个先发生那么就是下一个事件)；它们都容易做到。
虽然可能很耗时，但编写这样一个模拟例程还是很简单的。
如果有C个顾客(因此有2C个事件)和k个出纳员，那么模拟的运行时间将是O(Clog(k+1))，因为计算和处理每个事件花费O(logH)，其中H=k+1，为堆的大小。